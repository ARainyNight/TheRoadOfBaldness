

![1539179606637](图片\1539179606637.png)

A只能有final和abstract的一个，因为final是最终类，不能继承，必须可以创建实例，而abstract是抽象类，只能继承，不有实例。冲突了，所以不对。

B是抽象方法，不能有方法体。所以末尾不是{}而是；才对

C中 访问修饰符只能有一个，而且对象没有类型。

D正确，这是抽象类。

-----------

![1539179639806](图片\1539179639806.png)

----

![1539179668591](图片\1539179668591.png)

日志的级别之间的大小关系如右所示：ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF Log4j建议只使用四个级别，优先级从高到低分别是 ERROR > WARN > INFO > DEBUG。 log4j在运行期间是不可以重新设置的

------

```java
class A {
public A() {
System.out.println("class A");
}
{ System.out.println("I'm A class"); }
static { System.out.println("class A static"); }
}
public class B extends A {
public B() {
System.out.println("class B");
}
{ System.out.println("I'm B class"); }
static { System.out.println("class B static"); }
public static void main(String[] args) {
new B();
} 
}
```

![1539179779460](图片\1539179779460.png)

B继承A  new B会

1.把A的静态的执行完 执行B的静态的

2.再执行A的初始化代码块，构造函数

3.再执行B的初始化代码块，构造函数

-----

![1539179804965](图片\1539179804965.png)

A.除数为0 等ArithmeticException，是RuntimException的子类。而运行时异常将由运行时系统自动抛出，不需要使用throw语句。Java编译器允许忽略运行时异常，一个方法可以既不捕捉，也不声明抛出运行时异常。
C.产生NullPointerException。

---

![1539179879038](图片\1539179879038.png)

intValue()是把Integer对象类型变成int的基础数据类型；  parseInt()是把String 变成int的基础数据类型；  Valueof()是把String 转化成Integer对象类型；（现在JDK版本支持自动装箱拆箱了。） 本题：parseInt得到的是基础数据类型int，valueof得到的是装箱数据类型Integer，然后再通过valueInt转换成int，所以选择D 

----

![1539180155805](图片\1539180155805.png)

![](https://uploadfiles.nowcoder.net/images/20170214/2193220_1487038875892_072774B6B658B3603E1AA7198722775C)

----

![1539180314892](图片\1539180314892.png)

![1539180328461](图片\1539180328461.png)